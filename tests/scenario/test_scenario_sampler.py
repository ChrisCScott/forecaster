""" Unit tests for `ScenarioSampler`. """

import unittest
from unittest import mock
from datetime import datetime
from decimal import Decimal
import numpy
import dateutil
from forecaster.scenario import ScenarioSampler, Scenario, ReturnsTuple
from tests.scenario.test_historical_value_reader import (
    PORTFOLIO_VALUES, RETURNS_VALUES,
    TEST_PATH_PERCENTAGES, TEST_PATH_PORTFOLIO)

# Use constant seed for tests that rely on randomness:
RANDOM_TEST = numpy.random.default_rng(0)

class TestScenarioSampler(unittest.TestCase):
    """ A test suite for the `ScenarioSampler` class. """

    def setUp(self):
        # Copy values that get read from the `test_*.csv` files:
        self.values = dict(PORTFOLIO_VALUES)
        self.returns = dict(RETURNS_VALUES)
        self.data = ReturnsTuple(
            self.returns, self.returns, self.returns, self.returns)
        # Read in the same values for each variable:
        self.filenames = ReturnsTuple(
            TEST_PATH_PORTFOLIO, TEST_PATH_PORTFOLIO,
            TEST_PATH_PORTFOLIO, TEST_PATH_PORTFOLIO)
        # Use different values than the defaults so we can check:
        self.initial_year = 2000
        self.num_years = 2
        self.scenario = Scenario(
            self.initial_year, self.num_years, 1, 1, 1, 1, 1)

    def setUp_decimal(self):
        """ Convert numerical values to `Decimal` """
        # pylint: disable=invalid-name
        # `setUp` is the name used by `unittest`, it's not our fault!
        self.values = {
            key: Decimal(value) for (key, value) in self.values.items()}
        self.returns = {
            key: Decimal(value) for (key, value) in self.returns.items()}

    def test_num_samples(self):
        """ Test walk-forward sampler with `num_samples=2` """
        sampler = ScenarioSampler(
            ScenarioSampler.sampler_walk_forward, 2,
            self.scenario, filenames=None)
        sampler.data = self.data
        # Convert to list so we can count scenarios:
        scenarios = list(sampler)
        # There are only two valid walk-forward returns of length 2
        # with this dataset (which has only 3 datapoints)
        self.assertEqual(len(scenarios), 2)

    def test_wf_basic(self):
        """ Test walk-forward sampler scenario generation. """
        sampler = ScenarioSampler(
            ScenarioSampler.sampler_walk_forward, 2, self.scenario)
        # Convert to list so we can count scenarios:
        for scenario in sampler:
            year1_return = scenario.stock_return[self.initial_year]
            year2_return = scenario.stock_return[self.initial_year + 1]
            # There are only two valid walk-forward returns:
            # (0, 1) and (1, -0.25).
            if year1_return == 0:
                self.assertEqual(year2_return, 1)
            elif year1_return == 1:
                self.assertEqual(year2_return, -0.25)
            else:
                # This scenario isn't valid, so fail:
                self.fail("Invalid scenario generated by ScenarioSampler")
