""" Tests functions of the `utility.deepcopy` module. """

import copy
import unittest
from forecaster.utility.deepcopy import deepcopy, populate_memo

# pylint: disable=too-few-public-methods
# It's a dummy class for testing, what more do you want?
class Dummy():
    """ A dummy var for testing copying. """
    def __init__(self, val=None):
        self.val = val
# pylint: disable=too-few-public-methods

class TestDeepcopy(unittest.TestCase):
    """ Tests free functions of the `deepcopy` module. """

    def test_copy_basic(self):
        """ Test `deepcopy` acts like `copy.deepcopy` on non-functions. """
        # Build a nested structure:
        val = Dummy()
        val.val = Dummy()
        val.val.val = Dummy(0)
        copied_val = deepcopy(val)
        # Confirm that the copies are indeed copies, i.e. they are not
        # identical (via `is not`):
        self.assertIsNot(val, copied_val)
        self.assertIsNot(val.val, copied_val.val)
        self.assertIsNot(val.val.val, copied_val.val.val)
        # Confirm that the value of the leaf node is correct:
        self.assertEqual(val.val.val.val, copied_val.val.val.val)

    def test_copy_memo_compatible(self):
        """ Test `deepcopy` is compatible with `copy.deepcopy`'s `memo`. """
        memo = {}
        # Build a nested structure:
        val = Dummy()
        val.val = Dummy()
        val.val.val = Dummy(0)
        # Copy via custom `deepcopy`:
        copy1 = deepcopy(val, memo=memo)
        # Confirm that `copy.deepcopy` uses `memo` to avoid recursing:
        copy2 = copy.deepcopy(val, memo=memo)
        # `copy.deepcopy` should return the objects generated by
        # `deepcopy` - i.e. the IDs should be the same:
        self.assertIs(copy1, copy2)
        self.assertIs(copy1.val, copy2.val)
        self.assertIs(copy1.val.val, copy2.val.val)

    def test_copy_collection_function(self):
        """ Test `deepcopy` with a function element of a collection """
        # Give the function a closure to ensure that `deepcopy` tries
        # to copy it:
        var = 1
        # The function simply returns the object in the closure:
        def func():
            """ A function with a non-empty closure. """
            return var  # Returns 1
        # Wrap val in a collection (make it immutable, just for fun):
        val = (func,)
        val_copy = deepcopy(val)
        func_copy = val_copy[0]
        # The function should be a copy (different ID) and return the
        # same value:
        self.assertIsNot(func, func_copy)
        self.assertEqual(func_copy(), func())

    def test_replace_closure(self):
        """ Test `deepcopy` with a closured function as input. """
        # Use a dummy var for inclusion in the closure:
        original = Dummy()
        replacement = 1
        # The function simply returns the object in the closure:
        def func():
            """ A function with a non-empty closure. """
            return original  # returns None
        # Ask deepcopy to replace the dummy var with a new value (1):
        memo = populate_memo(original, replacement)
        func_copy = deepcopy(func, memo=memo)
        # The function should now return the new value:
        self.assertEqual(func_copy(), replacement)

    def test_copy_empty_closure(self):
        """ Test `deepcopy` with a non-closured function as input. """
        def func():
            """ A function with no closure. """
            return 1
        func_copy = deepcopy(func)
        # The copied function should return the same value as `func`
        self.assertEqual(func(), func_copy())
        # We don't test for whether the IDs of the functions are the
        # same, since for non-closured functions copying is not required

    def test_replace_function(self):
        """ Test replacing one function with another via `deepcopy`. """
        def func1():
            """ A function with no closure. """
            return 1
        def func2():
            """ Another function with no closure. """
            return 2
        # Ask deepcopy to replace `func1` with `func2`:
        memo = populate_memo(func1, func2)
        func_copy = deepcopy(func1, memo=memo)
        # The copy should be `func2`, the replacement function:
        self.assertIs(func_copy, func2)

    def test_replace_closure_scalar(self):
        """ Test `deepcopy` with special scalar attributes. """
        # Build dummy vars:
        original = Dummy(1)  # This is an original var that gets replaced
        replacement = Dummy(2)  # This var is the replacement
        unchanged = Dummy(1)  # This var doesn't get replaced
        def func():
            """ A function with a non-empty closure """
            return original.val + unchanged.val  # returns 2
        # Replace `original` with `replacement`:
        memo = populate_memo(original, replacement)
        func_copy = deepcopy(func, memo=memo)
        # If `deepcopy` worked properly, it replaced `original` with
        # `replacement` but did _not_ replace the `val` attr of the copy
        # of `unchanged` with 2, despite the `original` and `unchanged`
        # having attrs with the same ids (i.e. both are 1 originally).
        # The result should thus be 3, not 2 (failure to replace either)
        # or 4 (replacement of `original` and, erroneously, `unchanged`)
        self.assertEqual(func_copy(), 3)

    def test_populate_memo_keys(self):
        """ Test `populate_memo` generates keys like `deepcopy`. """
        # Build objects to copy:
        original = Dummy()
        original.val = Dummy(1)
        # Build replacement objects:
        replacement = Dummy()
        replacement.val = Dummy(2)
        # Build a memo via `deepcopy` and via `populate_deepcopy_memo`:
        memo1 = {}
        _ = copy.deepcopy(original, memo=memo1)
        memo2 = populate_memo(original, replacement)
        # The keys generated by `populate_deepcopy` should be keys that
        # would be generated by `copy.deepcopy`.
        # (We don't assert set equality because `copy.deepcopy`
        # generates additional keys that aren't relevant to object
        # replacement, such as keys that map to originals)
        self.assertTrue(set(memo2).issubset(set(memo1)))

    def test_populate_memo_values(self):
        """ Test `populate_memo` & `deepcopy` generate different values. """
        # Build objects to copy:
        original = Dummy()
        original.val = Dummy(1)
        # Build replacement objects:
        replacement = Dummy()
        replacement.val = Dummy(2)
        # Build a memo via `deepcopy` and via `populate_deepcopy_memo`:
        memo1 = {}
        copy_val = copy.deepcopy(original, memo=memo1)
        memo2 = populate_memo(original, replacement)
        # The replacement objects should be in `memo2` (and not `memo1`)
        self.assertIn(replacement, memo2.values())
        self.assertIn(replacement.val, memo2.values())
        self.assertNotIn(replacement, memo1.values())
        self.assertNotIn(replacement.val, memo1.values())
        # The copy.deepcopy-generated objects should be in `memo1`
        # (and not `memo2`)
        self.assertIn(copy_val, memo1.values())
        self.assertIn(copy_val.val, memo1.values())
        self.assertNotIn(copy_val, memo2.values())
        self.assertNotIn(copy_val.val, memo2.values())

if __name__ == '__main__':
    unittest.TextTestRunner().run(
        unittest.TestLoader().loadTestsFromName(__name__))
